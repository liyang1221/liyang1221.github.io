---
layout: post
title:  "Unity3D学习笔记：8，图形图像"
date:   2015-04-14
categories: Unity
tags: Unity StudyLine
---

###图形图像
3D游戏往往采用类似现实中拍摄视频的呈现手法。游戏设计师在场景中布置若干物体形成游戏世界，然后通过一部或多部摄像机的镜头呈现在屏幕面前。镜头往往跟随我们的主角移动，以在整个场景中漫游。本章涉及的正是这些内容：灯光、相机、地形系统等。<br><br>
####灯光
灯光在游戏场景中有十分重要的作用。游戏中的一切光线都是由灯光来模拟的，它使得物体显示明暗面、阴影等，让场景显得更加真实和自然。Unity的灯光也是以组件形式提供，附加到物体身上即可生效。在Inspector窗口查看Light的属性，Type有4种可选：<br>
Directional：方向光，灯光沿某个方向平行照射整个场景，光线没有明确的发射起点，因此运动过程中不会衰减。它的特殊性使得它的位置并不重要，可以放置在场景的任何位置，只要调整好方向即可。一般用来模拟环境光线。<br>
Point：点光，灯光从某个点向周围球形空间照射，可以调节球体的大小，光线在运动过程中会衰减。可以很方便地模拟游戏中的光源，如裸漏的灯泡等。<br>
Spot：灯光从某个点发射，但只沿某个锥形空间向前运动，可以调节锥形的大小和角度，运动过程中会衰减。用来模拟人造光源，如手电筒、路灯、车灯、探照灯等比较方便和合适。<br>
Area：区域光，通过一个矩形定义光线发射区域，光线从矩形的一侧沿任意方向发射，照亮特定的区域。这个类型的光源比较特殊，它可能从多个不同角度照射同一个物体，因此阴影的计算非常消耗性能，为了保证游戏的流畅，Unity不提供运行时实时区域光的功能，此光源只能通过烘培（Bake）到光照贴图（Lightmap）中生效。<br>
烘培是指对于场景中静态的物体，在设计时（而不是运行时）计算光照的影响，将结果缓存在称作“光照贴图”的文件中，运行时直接使用这些计算结果来呈现场景光照的技术。由于硬件技术的飞速发展，现在也可以在运行时实时计算光照，但必须理解，光照计算仍旧是非常消耗性能的，大多数时候，烘培都会很实用。<br>
每种类型的灯光都可以设置颜色（Color）和强度（Intensity），以及反射强度（Bounce Intensity，即光线照射到物体上被反射后的强度）。还有一些别的属性，如：<br>
Baking：选择Realtime时，光源的效果是运行时实时计算的，选择Baked时，光源只能通过烘培起作用，选择Mixed时，则是两者结合作用。<br>
Shadow Type：阴影类型，可选No，Hard或Soft。选择No则此光源不会对物体产生阴影，选择Hard则阴影具有明确的边界，选择Soft自然阴影边界比较柔和，看起来真实度更高一点，相应的对性能的消耗也高于前者。启用阴影后，可以设置阴影的分辨率、亮度等属性。<br>
Cookie：为灯光设置一个特殊的贴图，设置后影响光线照射到的物体表面的颜色。可以理解为用一张纹理挡在光线和物体之间，纹理上面的图案即可投影在物体表面。要将贴图设置为光源的Cookie，需要在导入时将Texture Type选为“Cookie”，并正确选择Light Type。<br>
Draw Halo：勾选此项，光源会开启光晕效果，即围绕光源的一个球形区域会被光的颜色填充（由近及远逐渐变淡）。<br>
Flare：耀斑/炫光，镜头光晕效果。添加了之后，当摄像机面对灯光时，将会出现光晕。Flare可以通过在Project窗口新建生成，然后选择一个贴图作为光晕渲染图。<br>
RenderMode 渲染模式。Unity中灯光以两种方法渲染：顶点和像素。顾名思义，顶点渲染是对物体每个顶点计算光照，然后在顶点之间插值计算表面光照，优点是计算速度快，支持的显卡多，缺点是一些特性不支持。而像素渲染则是对每个像素点进行光照计算，与前者恰好相反，它的渲染速度更慢，但是支持一些顶点光不支持的效果和特性，如cookies和实时阴影等技术也只能用这种渲染方式。可选项如下：<br>
	Auto：自动，根据光源的亮度以及运行时Quality Settings的设置等多种综合因素来确定光源的渲染模式。<br>
	Important：重要，逐像素进行渲染，一般用于非常重要的光源渲染。<br>
	Not Important：光源总是以最快的速度（逐顶点）进行渲染。<br>
Culling Mask ：设置光照起作用的层。<br>
对于Directional Light，由于它能照亮整个场景，因此它的阴影计算也会覆盖整个场景。这会造成一个称之为『perspective aliasing』的问题，简单来讲，计算出的阴影，在场景摄像机的透视视角下，较近的会被放大，并显示出锯齿边缘。通过在设置中提高阴影分辨率可以一定程度上缓解这个问题，但代价是计算量和显存的增加。还有一种较好的解决方案是按照距离摄像机的距离，将『Shadow map』划分成不同区域，较近的区域采用更高的分辨率计算阴影。在项目的『Quality Settings』设置项里面设置『Shadow Cascades』和『Cascade splits』来划分计算时分割的区域数量和每个区域的面积。<br>
在3D游戏中，光照和阴影计算一直是最复杂和消耗性能的地方之一。Unity的实时阴影计算采用『Shadow Map』技术，简单来讲，可以理解为灯光所处位置的一台摄像机，以灯光的发射方向观察场景，能看到的最表面的一层区域就是被照亮的区域，剩下的区域为阴影区。为了最大限度节约性能，Unity对网格渲染器提供了关闭接受阴影和关闭产生阴影的选项（意味着场景中每个物体都可以忽略光照），每个灯光也都可以设置是否产生阴影，对于移动平台等对性能更敏感的平台，应尽量减少实时阴影的计算，而更多地采用烘培技术。<br>
通过编辑器的菜单项『Window』->『Lighting』可以打开场景的烘培设置。窗口集成了3个tab页，分别是『Object、Scene、Lightmaps』。<br>
Object页可以设置场景中游戏物体的光照烘培。通过“Scene Filter”可以快速筛选不同类别的物体，选中物体后，可以在下方进行设置。如果选中项是灯光，则设置项与Inspector窗口显示的是一样的，不再重复说；如果选中的是Renderer，第一个选项“Lightmap Static”勾选则表明物体是静态物体（运行时不会改动transform），后面才可以继续设置。下一个选项“Scale in Lightmap”用来设置此物体在生成的lightmap贴图中占的位置大小。默认值1表示按照物体表面的区域大小来计算，值越大，则此物体在lightmap中所占的比例就越大。下一个选项“Preserve UVs”，如果勾选，则lightmap中会保留物体的uv坐标，否则，lightmap会根据实际情况打乱uv坐标以尽可能的压缩生成的lightmap体积。“Important GI”，表明从这个物体反射的光线会显著影响其它物体，以避免一些细微的效果在计算时被优化掉。<br>
Scene页设置整个场景的烘培选项。包括几类设置，第一类是“Environment Lighting”：<br>
Skybox是设置场景的天空盒；<br>
Sun是设置场景的“太阳”，它是场景中的一个灯光，如果不指定，会选择场景中最亮的那一盏灯，它的作用是可以模拟太阳，当你旋转灯光的角度，它能动态调节天空盒的外观和场景的光线亮度来模拟不同的时刻（早上/中午/傍晚/夜晚等）；<br>
Ambient Source可以设置环境光的来源，可以指定具体的颜色或按照天空盒的颜色。<br>
Ambient Intensity设置环境光的强度；<br>
Ambient GI设置环境光渲染模式（实时或者烘培）；<br>
Reflection Source：设置镜面反射源。<br>
Reflection Intensity：设置镜面反射的强度；<br>
Reflection Bounces：设置镜面反射回弹的次数；<br>
第二类是Precomputed Realtime GI，即预处理实时光照，可以选择预处理的分辨率和CPU使用率限制。<br>
第三类是Baked GI，设置烘培光照的分辨率（Baked Resolution）、lightmap的间隙（Baked Padding）、是否压缩（Compressed）等选项，以及Final Gather：开启后，最终的灯光反射计算会使用跟lightmap相同的分辨率计算，这样会提高lightmap的质量，代价是烘培的时间会变长。<br>
第四类是General GI，设置对烘培和实时光都有效。<br>
Directional Mode：当设置为Directional或者Directional Specular，会生成额外的lightmap存储更多计算信息，以支持更多的光照和阴影特性，提升场景品质。Directional大约消耗原来两倍的lightmap存储空间，Directional Specular大约消耗4倍的存储空间和2倍的纹理内存。<br>
Indirect Intensity：设置indirect light（也就是环境光、物体表面反射光等）的亮度比例，默认值1.0。<br>
Bounce Boost：设置从物体表面反射的光线的强度比例，默认是1.0。<br>
Default Parameters：选择lightmap使用的设置集。可以通过【Project】->【Create】->【Lightmap Parameters】新建一个设置集，然后在此处指定使用它。通过设置集可以设置生成lightmap的各种属性。<br>
Atlas Size：控制生成的lightmap图集的分辨率。<br>
第五类是Fog，即场景中的雾效果。可以设置颜色、插值方式（线性、指数等）、有效区域等参数。<br>
最后一类是Other Settings，设置项包括光晕、闪光等参数。<br>
Lightmaps页展示了当前生成的lightmap。<br>
此外，在任何一个tab页都会有『Continuous Baking』复选框，选中的话，场景会持续自动烘培，即每当有变化就会在后台进行烘培，这样单次烘培所需的时间一般较少；反之不勾选的话，则需要自己在合适的时机点击『Build』按钮进行烘培，才能看到效果。<br>
由于lightmap技术只能针对场景中的静态物体作用，为了使动态物体也能融入场景中，Unity提供了一种叫做“Light Probes”的技术手段。它的原理是通过在场景的特定位置放置“探针”来记录此位置的光照信息（当然这种计算是通过烘培进行的），这样运行的时候场景中任意一点的光照信息就可以拿它周围最近的一些Probe插值计算，这样虽然不会非常精确，但是效果大致上是正确的，且计算速度是可以接受的。<br>
通过为任意物体添加Light Probe Group组件即可在场景中添加一组Light Probe。可以添加或减少Probe的数量，改变它们的位置等。由于每个Probe都会消耗更多的内存空间，因此应尽量减少Probe的数量，并合理布置它们的位置（比如在光线平稳的区域、在动态物体不会到达的区域等就没必要布置很多Probe）。添加完成后，还需要勾选需要接收Probe影响的动态物体的Mesh Renderer组件的Use Light Probes选项才能生效。<br>
<br>
####相机
游戏场景中的内容都需要通过相机才能呈现在屏幕面前，可以说，相机提供了玩家探索游戏世界的入口。在Unity中新建场景时会默认添加一个相机，也可以通过『GameObject』->『Camera』菜单项添加更多的相机。每部相机都可以设置在屏幕上的显示区域，每帧渲染时，所有的相机渲染结果叠加显示在屏幕上。<br>
相机也是通过组件提供的，除了使用系统自动添加的相机外，也可以通过给物体挂载Camera组件来手动添加相机。在Inspector窗口可以调整它的属性，包括：<br>
Background：设置相机的背景色，它的作用见下文；<br>
Clear Flags：设置相机渲染时，如何控制背景的显示。这里所谓的“背景”是指，相机视图中没有被任何物体覆盖到的区域。一般采用的方法是，在渲染场景前先将背景渲染，然后在背景之上渲染场景，这样最终显示就是正常的。有4种可选的选项，最简单的是Solid Color，即使用单一颜色填充背景，可以通过相机的Background设置填充颜色。最常用的是Skybox，即使用天空盒填充背景。天空盒是一种3D渲染中常用的用来模拟环境的技术，它的原理是使用一个立方体“盒子”将整个场景包裹在内，然后在盒子内侧6个墙壁上铺上6张边缘互相衔接的贴图。这个虚拟的盒子距离相机是无限远的，因此从它内部观察场景，相机背景就会自然地被天空盒的贴图填充。每个场景可以设置一个天空盒（材质），每个相机也可以挂载一个Skybox组件并指定自己的天空盒材质。当设置ClearFlags为Skybox后，优先使用相机挂载的Skybox组件，如果没有则使用场景的Skybox，如果还没有则使用Background填充。第三个选项是Depth only，在这种模式下，相机只渲染场景中的物体，并与其它相机（如果有）叠加显示，适合用于多个相机混合使用的情形。最后一种是Don't Clear，即不进行处理。在这种情况下，每一帧显示的画面将会叠加在上一帧显示的内容之上，这种情况用的较少。<br>
Culling Mask：选择相机要渲染的Layers。场景可以划分若干层，每个物体都可以选择所在的层（默认为内置的Default层），每个相机都可以选择要渲染的层（可以多选），此外，碰撞检测/射线检测等也会涉及到层。<br>
Projection：相机的视图模式。可选Perspective（透视视图）或者Orthographic（正交视图）。Perspective模拟了现实中3维空间的视角，即物体距离相机越远看起来越小，此时相机的视野是一个锥形体；而Orthographic则以真实大小呈现物体，无论距离的远近，视野是立方体。当选择Perspective时，可以通过Field of View调节可视角度，当选择Orthographic时，可以通过Size调节视野的宽度，两者都可以通过Clipping Planes调节远近裁剪面。<br>
ViewPort Rect：设置相机在屏幕显示的区域。XY控制区域位置，WH控制区域大小。此处的数值都是比例（0-1），以屏幕左下角为0，右上角为1。比如指定（X，Y，W，H）=（0.5,0.5,0.5,0.5），则相机显示区域为屏幕右上角1/4屏幕大小的区域。<br>
Depth：控制相机的渲染深度。深度越大的相机渲染顺序越靠后，会覆盖深度较浅的相机渲染内容。<br>
Rendering Path：设置相机的渲染路径。不同的值会影响光照和阴影的质量，以及不同的性能消耗和硬件兼容性。<br>
