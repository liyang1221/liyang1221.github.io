---
layout: post
title:  "Unity3D Demo：24点游戏"
date:   2015-04-09
categories: Unity
tags: Unity Demo
unityfile: "/files/24point.unity3d"
unitywidth: 800
unityheight: 400
---

###背景：

<!-- begin_summary -->

有网友要做一个24点的小游戏，问怎么在Unity中解析类似“1*（2+3）-4”这样的字符串表达式。依稀记得当年数据结构课上有这类例子，回头翻了下，果然，就是中缀表达式转后缀表达式，然后计算结果的问题。空闲下来就写了个简单的demo。

<!-- end_summary -->

###效果：
{% include unity.html %}

###分析：

关于中缀表达式、后缀表达式的概念与转换思想，已经有很多博文来讲述，本文就不再详述，简单搬运一下思路。<br>
中缀表达式转后缀表达式：<br>
1.遇到操作数：直接输出（添加到后缀表达式中）<br>
2.栈为空时，遇到运算符，直接入栈<br>
3.遇到左括号：将其入栈<br>
4.遇到右括号：执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出。<br>
5.遇到其他运算符：加减乘除：弹出所有优先级大于或者等于该运算符的栈顶元素，然后将该运算符入栈<br>
6.最终将栈中的元素依次出栈，输出。<br>
后缀表达式的计算：<br>
建立一个栈S 。从左到右读表达式，如果读到操作数就将它压入栈S中，如果读到n元运算符(即需要参数个数为n的运算符)则取出由栈顶向下的n项按操作符运算，再将运算的结果代替原栈顶的n项，压入栈S中 。如果后缀表达式未读完，则重复上面过程，最后输出栈顶的数值则为结束。<br>
借此机会，顺便介绍下Unity如何引入.net编写的类库。其实过程倒没什么复杂，直接把.net类库丢进Unity的项目Assets目录下，然后在项目中就可以直接调用了。需要注意的是Unity使用的是Mono的运行时，它跟官方.net是有一些区别的，写类库时要注意不要引用这些内容，以及，Mono目前的版本大致相当于.net3.5的版本，因此编写类库尽量使用3.5以下的版本。<br>

###实现：

####1，打开Visual Studio，新建一个C#类库项目，版本选择.Net 3.5：<br>
在项目中新建一个类，命名为 ExpCalc.cs，内容如下：

{% highlight csharp %}

using System;
using System.Collections.Generic;
using System.Linq;

namespace ExpCalc
{
    public class ExpCalc
    {
        public static double CalcStringExp(string exp)
        {
            try
            {
                var nfe = Exp2NFE(exp.Replace(" ", ""));

                var pfe = NFE2PFE(nfe);

                return CalcPFE(pfe);
            }
            catch
            {
                throw new Exception("input expression invalid!");
            }
        }

        public static bool TryCalcStringExp(string exp, out double result)
        {
            try
            {
                result = CalcStringExp(exp);
                return true;
            }
            catch
            {
                result = 0;
                return false;
            }
        }

        static IEnumerable<string> Exp2NFE(string exp)
        {
            List<string> nfe = new List<string>();
            var startIndex = 0;
            var index = exp.IndexOfAny(Operator.Opes, startIndex);

            while (index != -1)
            {
                if (index > startIndex)
                {
                    nfe.Add(exp.Substring(startIndex, index - startIndex));
                }
                nfe.Add(exp[index].ToString());

                startIndex = index + 1;
                index = exp.IndexOfAny(Operator.Opes, startIndex);
            }
            if (startIndex < exp.Length)
            {
                nfe.Add(exp.Substring(startIndex));
            }
            return nfe;
        }

        static IEnumerable<string> NFE2PFE(IEnumerable<string> nfe)
        {
            List<string> pfe = new List<string>(nfe.Count());

            Stack<char> stack = new Stack<char>(pfe.Count);

            foreach (var str in nfe)
            {
                if (str.Length == 1 && Operator.Opes.Contains(str[0]))
                {
                    var checkOpe = str[0];
                    if (stack.Count == 0)
                    {
                        stack.Push(checkOpe);
                    }
                    else if (Operator.IsLeftBracket(checkOpe))
                    {
                        stack.Push(checkOpe);
                    }
                    else if (Operator.IsRightBracket(checkOpe))
                    {
                        while (stack.Count > 0 && !Operator.IsLeftBracket(stack.Peek()))
                        {
                            pfe.Add(stack.Pop().ToString());
                        }
                        stack.Pop();
                    }
                    else
                    {
                        while (stack.Count > 0 && !Operator.IsLeftBracket(stack.Peek()) && Operator.IsLower(checkOpe, stack.Peek()))
                        {
                            pfe.Add(stack.Pop().ToString());
                        }
                        stack.Push(checkOpe);
                    }
                }
                else
                {
                    pfe.Add(str);
                }
            }
            while (stack.Count > 0)
            {
                pfe.Add(stack.Pop().ToString());
            }

            return pfe;
        }

        static double CalcPFE(IEnumerable<string> pfe)
        {
            Stack<double> stack = new Stack<double>();

            foreach (var str in pfe)
            {
                if (str.Length == 1 && Operator.Opes.Contains(str[0]))
                {
                    var num2 = stack.Pop();
                    var num1 = stack.Pop();
                    stack.Push(Operator.Calc(str[0], num1, num2));
                }
                else
                {
                    stack.Push(Convert.ToDouble(str));
                }
            }
            return stack.Pop();
        }
    }

    class Operator
    {
        public static readonly char[] Opes = { ')','+','-','*','/','(' };

        public static bool IsLower(char checkOpe, char baseOpe)
        {
            return Compare(checkOpe, baseOpe) <= 0;
        }

        public static bool IsRightBracket(char c)
        {
            return c == Opes[0];
        }

        public static bool IsLeftBracket(char c)
        {
            return c == Opes[Opes.Length - 1];
        }

        public static int Compare(char ope1, char ope2)
        {
            var index1 = Array.IndexOf<char>(Opes, ope1);
            var index2 = Array.IndexOf<char>(Opes, ope2);

            return index1 / 3 - index2 / 3;
        }

        public static double Calc(char ope, double num1, double num2)
        {
            double ret = 0;
            switch (ope)
            {
                case '+': ret = num1 + num2; break;
                case '-': ret = num1 - num2; break;
                case '*': ret = num1 * num2; break;
                case '/': ret = num1 / num2; break;
            }
            return ret;
        }
    }
}

{% endhighlight %}

两个公共接口CalcStringExp和TryCalcStringExp，区别只是一个会抛出异常另一个不会。Exp2NFE负责将输入字符串表达式拆分为中缀表达式集合，NFE2PFE负责将中缀表达式集合转换为后缀表达式集合，CalcPFE负责计算后缀表达式集合的结果。算法就是按照上面介绍的思想直接翻译成了代码，冏。。辅助类Operator定义了一些合法的操作符。<br>
然后生成项目，得到一个dll文件。将它放到Unity项目的Assets目录下（随便哪个子目录都可以）。

####2，Unity中调用类库：<br>
此时切换到Unity编辑器，它会识别到有兼容的类库被添加进来，于是进行编译合并进项目。编译完成后，就可以直接使用了。<br>
后面就是一些简单的UI工作，我使用uGUI布置出24点游戏的界面（上面一个显示区域，下面一排按钮随机给出4个数字（范围1-13），再下面是操作符，最下面一排是控制按钮）。当点击数字按钮或者操作符按钮时，直接将它写入到显示区域，点击『OK』按钮计算时，将显示区域的字符串传进类库进行计算。各个按钮的回调方法如下：

{% highlight csharp %}

public class PointEventHandler : MonoBehaviour {

    public Text screen;
    public Text num1, num2, num3, num4;
    bool hasSubmit = false;

    void Start()
    {
        OnRestartClick();
    }

    //按下数字按钮的回调，参数表明是第几个按钮
    public void OnNumClick(int num)
    {
        Text txt = null;
        switch (num)
        {
            case 1: txt= num1; break;
            case 2: txt= num2; break;
            case 3: txt= num3; break;
            case 4: txt= num4; break;
        }
        screen.text += txt.text;
        txt.transform.parent.gameObject.SetActive(false);
    }

    //按下操作符按钮的回调，参数表明操作符的符号
    public void OnOpeClick(string ope)
    {
        if (hasSubmit) return;

        screen.text += ope;
    }

    public void OnOKClick()
    {
        if (hasSubmit) return;

        var error = string.Empty;
        float ret = 0;
        try
        {
            ret = (float)ExpCalc.ExpCalc.CalcStringExp(screen.text);
        }
        catch (System.Exception e)
        {
            error = e.Message;
        }
        if (Mathf.Abs(ret - 24) < 0.5f)
        {
            screen.text = "success";
        }
        else
        {
            screen.text = "wrong：" + error;
        }
        hasSubmit = true;
    }

    public void OnClearClick()
    {
        screen.text = string.Empty;
        num1.transform.parent.gameObject.SetActive(true);
        num2.transform.parent.gameObject.SetActive(true);
        num3.transform.parent.gameObject.SetActive(true);
        num4.transform.parent.gameObject.SetActive(true);
        hasSubmit = false;
    }

    public void OnRestartClick()
    {
        OnClearClick();
        num1.text = Random.Range(1, 14).ToString();
        num2.text = Random.Range(1, 14).ToString();
        num3.text = Random.Range(1, 14).ToString();
        num4.text = Random.Range(1, 14).ToString();
    }
}

{% endhighlight %}

可以发现，类库用起来也是相当的直观，跟项目中代码是无缝集成的。

###示例代码下载（Unity5.0）
[24point.unitypackage](/files/24point.unitypackage "24point.unitypackage")
